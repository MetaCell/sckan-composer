/* tslint:disable */
/* eslint-disable */
/**
 * SCKAN Composer API
 * SCKAN Composer API
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * Anatomical Entity
 * @export
 * @interface AnatomicalEntity
 */
export interface AnatomicalEntity {
    /**
     * 
     * @type {number}
     * @memberof AnatomicalEntity
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof AnatomicalEntity
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AnatomicalEntity
     */
    'ontology_uri': string;
}
/**
 * ANS Division
 * @export
 * @interface AnsDivision
 */
export interface AnsDivision {
    /**
     * 
     * @type {number}
     * @memberof AnsDivision
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof AnsDivision
     */
    'name': string;
}
/**
 * BiologicalSex
 * @export
 * @interface BiologicalSex
 */
export interface BiologicalSex {
    /**
     * 
     * @type {number}
     * @memberof BiologicalSex
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof BiologicalSex
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BiologicalSex
     */
    'ontology_uri': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CircuitTypeEnum = {
    Sensory: 'SENSORY',
    Motor: 'MOTOR',
    Intrinsic: 'INTRINSIC',
    Projection: 'PROJECTION',
    Anaxonic: 'ANAXONIC',
    Unknown: 'UNKNOWN'
} as const;

export type CircuitTypeEnum = typeof CircuitTypeEnum[keyof typeof CircuitTypeEnum];


/**
 * Connectivity Statement
 * @export
 * @interface ConnectivityStatement
 */
export interface ConnectivityStatement {
    /**
     * 
     * @type {number}
     * @memberof ConnectivityStatement
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof ConnectivityStatement
     */
    'sentence_id': number;
    /**
     * 
     * @type {Sentence}
     * @memberof ConnectivityStatement
     */
    'sentence': Sentence;
    /**
     * 
     * @type {string}
     * @memberof ConnectivityStatement
     */
    'knowledge_statement': string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof ConnectivityStatement
     */
    'tags': Array<Tag>;
    /**
     * 
     * @type {Array<Doi>}
     * @memberof ConnectivityStatement
     */
    'dois': Array<Doi>;
    /**
     * 
     * @type {User}
     * @memberof ConnectivityStatement
     */
    'owner': User;
    /**
     * 
     * @type {number}
     * @memberof ConnectivityStatement
     */
    'owner_id'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ConnectivityStatement
     */
    'state': string;
    /**
     * 
     * @type {Array<ConnectivityStatementAvailableTransitionsEnum>}
     * @memberof ConnectivityStatement
     */
    'available_transitions': Array<ConnectivityStatementAvailableTransitionsEnum>;
    /**
     * 
     * @type {number}
     * @memberof ConnectivityStatement
     */
    'origin_id'?: number;
    /**
     * 
     * @type {AnatomicalEntity}
     * @memberof ConnectivityStatement
     */
    'origin': AnatomicalEntity;
    /**
     * 
     * @type {number}
     * @memberof ConnectivityStatement
     */
    'destination_id'?: number;
    /**
     * 
     * @type {AnatomicalEntity}
     * @memberof ConnectivityStatement
     */
    'destination': AnatomicalEntity;
    /**
     * 
     * @type {number}
     * @memberof ConnectivityStatement
     */
    'ans_division_id': number;
    /**
     * 
     * @type {AnsDivision}
     * @memberof ConnectivityStatement
     */
    'ans_division': AnsDivision;
    /**
     * 
     * @type {DestinationTypeEnum}
     * @memberof ConnectivityStatement
     */
    'destination_type'?: DestinationTypeEnum;
    /**
     * 
     * @type {Array<Via>}
     * @memberof ConnectivityStatement
     */
    'path': Array<Via>;
    /**
     * 
     * @type {string}
     * @memberof ConnectivityStatement
     */
    'journey': string;
    /**
     * 
     * @type {LateralityEnum}
     * @memberof ConnectivityStatement
     */
    'laterality'?: LateralityEnum;
    /**
     * 
     * @type {CircuitTypeEnum}
     * @memberof ConnectivityStatement
     */
    'circuit_type'?: CircuitTypeEnum;
    /**
     * 
     * @type {Array<Specie>}
     * @memberof ConnectivityStatement
     */
    'species': Array<Specie>;
    /**
     * 
     * @type {number}
     * @memberof ConnectivityStatement
     */
    'biological_sex_id': number;
    /**
     * 
     * @type {BiologicalSex}
     * @memberof ConnectivityStatement
     */
    'biological_sex': BiologicalSex;
    /**
     * 
     * @type {string}
     * @memberof ConnectivityStatement
     */
    'apinatomy_model'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ConnectivityStatement
     */
    'modified_date': string;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectivityStatement
     */
    'has_notes': boolean;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ConnectivityStatementAvailableTransitionsEnum = {
    Draft: 'draft',
    ComposeNow: 'compose_now',
    Curated: 'curated',
    Excluded: 'excluded',
    Rejected: 'rejected',
    ToBeReviewed: 'to_be_reviewed',
    ConnectionMissing: 'connection_missing',
    NpoApproved: 'npo_approved',
    Approved: 'approved'
} as const;

export type ConnectivityStatementAvailableTransitionsEnum = typeof ConnectivityStatementAvailableTransitionsEnum[keyof typeof ConnectivityStatementAvailableTransitionsEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const DestinationTypeEnum = {
    AxonSe: 'AXON-SE',
    AxonT: 'AXON-T',
    AxonSt: 'AXON-ST',
    Unknow: 'UNKNOW'
} as const;

export type DestinationTypeEnum = typeof DestinationTypeEnum[keyof typeof DestinationTypeEnum];


/**
 * Doi
 * @export
 * @interface Doi
 */
export interface Doi {
    /**
     * 
     * @type {number}
     * @memberof Doi
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Doi
     */
    'doi': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const LateralityEnum = {
    Ipsi: 'IPSI',
    Ontrat: 'ONTRAT',
    Bi: 'BI',
    Unknown: 'UNKNOWN'
} as const;

export type LateralityEnum = typeof LateralityEnum[keyof typeof LateralityEnum];


/**
 * 
 * @export
 * @interface Login
 */
export interface Login {
    /**
     * 
     * @type {number}
     * @memberof Login
     */
    'status_code': number;
    /**
     * 
     * @type {string}
     * @memberof Login
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof Login
     */
    'redirect_url'?: string;
}
/**
 * 
 * @export
 * @interface Logout
 */
export interface Logout {
    /**
     * 
     * @type {number}
     * @memberof Logout
     */
    'status_code': number;
    /**
     * 
     * @type {string}
     * @memberof Logout
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof Logout
     */
    'redirect_url'?: string;
}
/**
 * Note
 * @export
 * @interface Note
 */
export interface Note {
    /**
     * 
     * @type {string}
     * @memberof Note
     */
    'note': string;
    /**
     * 
     * @type {string}
     * @memberof Note
     */
    'user': string | null;
    /**
     * 
     * @type {string}
     * @memberof Note
     */
    'created_at': string;
    /**
     * 
     * @type {number}
     * @memberof Note
     */
    'connectivity_statement_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Note
     */
    'sentence_id'?: number;
}
/**
 * 
 * @export
 * @interface PaginatedAnatomicalEntityList
 */
export interface PaginatedAnatomicalEntityList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedAnatomicalEntityList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedAnatomicalEntityList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedAnatomicalEntityList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<AnatomicalEntity>}
     * @memberof PaginatedAnatomicalEntityList
     */
    'results'?: Array<AnatomicalEntity>;
}
/**
 * 
 * @export
 * @interface PaginatedAnsDivisionList
 */
export interface PaginatedAnsDivisionList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedAnsDivisionList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedAnsDivisionList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedAnsDivisionList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<AnsDivision>}
     * @memberof PaginatedAnsDivisionList
     */
    'results'?: Array<AnsDivision>;
}
/**
 * 
 * @export
 * @interface PaginatedBiologicalSexList
 */
export interface PaginatedBiologicalSexList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedBiologicalSexList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedBiologicalSexList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedBiologicalSexList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<BiologicalSex>}
     * @memberof PaginatedBiologicalSexList
     */
    'results'?: Array<BiologicalSex>;
}
/**
 * 
 * @export
 * @interface PaginatedConnectivityStatementList
 */
export interface PaginatedConnectivityStatementList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedConnectivityStatementList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedConnectivityStatementList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedConnectivityStatementList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<ConnectivityStatement>}
     * @memberof PaginatedConnectivityStatementList
     */
    'results'?: Array<ConnectivityStatement>;
}
/**
 * 
 * @export
 * @interface PaginatedNoteList
 */
export interface PaginatedNoteList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedNoteList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedNoteList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedNoteList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Note>}
     * @memberof PaginatedNoteList
     */
    'results'?: Array<Note>;
}
/**
 * 
 * @export
 * @interface PaginatedSentenceList
 */
export interface PaginatedSentenceList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedSentenceList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSentenceList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSentenceList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Sentence>}
     * @memberof PaginatedSentenceList
     */
    'results'?: Array<Sentence>;
}
/**
 * 
 * @export
 * @interface PaginatedSpecieList
 */
export interface PaginatedSpecieList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedSpecieList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSpecieList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSpecieList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Specie>}
     * @memberof PaginatedSpecieList
     */
    'results'?: Array<Specie>;
}
/**
 * 
 * @export
 * @interface PaginatedTagList
 */
export interface PaginatedTagList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedTagList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedTagList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedTagList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof PaginatedTagList
     */
    'results'?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface PaginatedViaList
 */
export interface PaginatedViaList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedViaList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedViaList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedViaList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Via>}
     * @memberof PaginatedViaList
     */
    'results'?: Array<Via>;
}
/**
 * Connectivity Statement
 * @export
 * @interface PatchedConnectivityStatement
 */
export interface PatchedConnectivityStatement {
    /**
     * 
     * @type {number}
     * @memberof PatchedConnectivityStatement
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedConnectivityStatement
     */
    'sentence_id'?: number;
    /**
     * 
     * @type {Sentence}
     * @memberof PatchedConnectivityStatement
     */
    'sentence'?: Sentence;
    /**
     * 
     * @type {string}
     * @memberof PatchedConnectivityStatement
     */
    'knowledge_statement'?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof PatchedConnectivityStatement
     */
    'tags'?: Array<Tag>;
    /**
     * 
     * @type {Array<Doi>}
     * @memberof PatchedConnectivityStatement
     */
    'dois'?: Array<Doi>;
    /**
     * 
     * @type {User}
     * @memberof PatchedConnectivityStatement
     */
    'owner'?: User;
    /**
     * 
     * @type {number}
     * @memberof PatchedConnectivityStatement
     */
    'owner_id'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedConnectivityStatement
     */
    'state'?: string;
    /**
     * 
     * @type {Array<ConnectivityStatementAvailableTransitionsEnum>}
     * @memberof PatchedConnectivityStatement
     */
    'available_transitions'?: Array<ConnectivityStatementAvailableTransitionsEnum>;
    /**
     * 
     * @type {number}
     * @memberof PatchedConnectivityStatement
     */
    'origin_id'?: number;
    /**
     * 
     * @type {AnatomicalEntity}
     * @memberof PatchedConnectivityStatement
     */
    'origin'?: AnatomicalEntity;
    /**
     * 
     * @type {number}
     * @memberof PatchedConnectivityStatement
     */
    'destination_id'?: number;
    /**
     * 
     * @type {AnatomicalEntity}
     * @memberof PatchedConnectivityStatement
     */
    'destination'?: AnatomicalEntity;
    /**
     * 
     * @type {number}
     * @memberof PatchedConnectivityStatement
     */
    'ans_division_id'?: number;
    /**
     * 
     * @type {AnsDivision}
     * @memberof PatchedConnectivityStatement
     */
    'ans_division'?: AnsDivision;
    /**
     * 
     * @type {DestinationTypeEnum}
     * @memberof PatchedConnectivityStatement
     */
    'destination_type'?: DestinationTypeEnum;
    /**
     * 
     * @type {Array<Via>}
     * @memberof PatchedConnectivityStatement
     */
    'path'?: Array<Via>;
    /**
     * 
     * @type {string}
     * @memberof PatchedConnectivityStatement
     */
    'journey'?: string;
    /**
     * 
     * @type {LateralityEnum}
     * @memberof PatchedConnectivityStatement
     */
    'laterality'?: LateralityEnum;
    /**
     * 
     * @type {CircuitTypeEnum}
     * @memberof PatchedConnectivityStatement
     */
    'circuit_type'?: CircuitTypeEnum;
    /**
     * 
     * @type {Array<Specie>}
     * @memberof PatchedConnectivityStatement
     */
    'species'?: Array<Specie>;
    /**
     * 
     * @type {number}
     * @memberof PatchedConnectivityStatement
     */
    'biological_sex_id'?: number;
    /**
     * 
     * @type {BiologicalSex}
     * @memberof PatchedConnectivityStatement
     */
    'biological_sex'?: BiologicalSex;
    /**
     * 
     * @type {string}
     * @memberof PatchedConnectivityStatement
     */
    'apinatomy_model'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedConnectivityStatement
     */
    'modified_date'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedConnectivityStatement
     */
    'has_notes'?: boolean;
}


/**
 * Note
 * @export
 * @interface PatchedNote
 */
export interface PatchedNote {
    /**
     * 
     * @type {string}
     * @memberof PatchedNote
     */
    'note'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedNote
     */
    'user'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedNote
     */
    'created_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedNote
     */
    'connectivity_statement_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedNote
     */
    'sentence_id'?: number;
}
/**
 * Sentence
 * @export
 * @interface PatchedSentence
 */
export interface PatchedSentence {
    /**
     * 
     * @type {number}
     * @memberof PatchedSentence
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedSentence
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedSentence
     */
    'text'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedSentence
     */
    'pmid'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedSentence
     */
    'pmcid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedSentence
     */
    'doi'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedSentence
     */
    'batch_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedSentence
     */
    'external_ref'?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof PatchedSentence
     */
    'tags'?: Array<Tag>;
    /**
     * 
     * @type {User}
     * @memberof PatchedSentence
     */
    'owner'?: User;
    /**
     * 
     * @type {number}
     * @memberof PatchedSentence
     */
    'owner_id'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedSentence
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedSentence
     */
    'modified_date'?: string;
    /**
     * 
     * @type {Array<SentenceAvailableTransitionsEnum>}
     * @memberof PatchedSentence
     */
    'available_transitions'?: Array<SentenceAvailableTransitionsEnum>;
    /**
     * 
     * @type {Array<SentenceConnectivityStatement>}
     * @memberof PatchedSentence
     */
    'connectivity_statements'?: Array<SentenceConnectivityStatement>;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedSentence
     */
    'has_notes'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedSentence
     */
    'pmid_uri'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedSentence
     */
    'pmcid_uri'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedSentence
     */
    'doi_uri'?: string;
}
/**
 * Via
 * @export
 * @interface PatchedVia
 */
export interface PatchedVia {
    /**
     * 
     * @type {number}
     * @memberof PatchedVia
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedVia
     */
    'display_order'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedVia
     */
    'connectivity_statement_id'?: number;
    /**
     * 
     * @type {AnatomicalEntity}
     * @memberof PatchedVia
     */
    'anatomical_entity'?: AnatomicalEntity;
}
/**
 * Profile
 * @export
 * @interface Profile
 */
export interface Profile {
    /**
     * 
     * @type {number}
     * @memberof Profile
     */
    'id': number;
    /**
     * 
     * @type {User}
     * @memberof Profile
     */
    'user': User;
    /**
     * 
     * @type {boolean}
     * @memberof Profile
     */
    'is_triage_operator'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Profile
     */
    'is_curator'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Profile
     */
    'is_reviewer'?: boolean;
}
/**
 * Sentence
 * @export
 * @interface Sentence
 */
export interface Sentence {
    /**
     * 
     * @type {number}
     * @memberof Sentence
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Sentence
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Sentence
     */
    'text': string;
    /**
     * 
     * @type {number}
     * @memberof Sentence
     */
    'pmid'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Sentence
     */
    'pmcid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Sentence
     */
    'doi'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Sentence
     */
    'batch_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Sentence
     */
    'external_ref': string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Sentence
     */
    'tags': Array<Tag>;
    /**
     * 
     * @type {User}
     * @memberof Sentence
     */
    'owner': User;
    /**
     * 
     * @type {number}
     * @memberof Sentence
     */
    'owner_id'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Sentence
     */
    'state': string;
    /**
     * 
     * @type {string}
     * @memberof Sentence
     */
    'modified_date': string;
    /**
     * 
     * @type {Array<SentenceAvailableTransitionsEnum>}
     * @memberof Sentence
     */
    'available_transitions': Array<SentenceAvailableTransitionsEnum>;
    /**
     * 
     * @type {Array<SentenceConnectivityStatement>}
     * @memberof Sentence
     */
    'connectivity_statements': Array<SentenceConnectivityStatement>;
    /**
     * 
     * @type {boolean}
     * @memberof Sentence
     */
    'has_notes': boolean;
    /**
     * 
     * @type {string}
     * @memberof Sentence
     */
    'pmid_uri': string;
    /**
     * 
     * @type {string}
     * @memberof Sentence
     */
    'pmcid_uri': string;
    /**
     * 
     * @type {string}
     * @memberof Sentence
     */
    'doi_uri': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SentenceAvailableTransitionsEnum = {
    Open: 'open',
    ToBeReviewed: 'to_be_reviewed',
    ComposeLater: 'compose_later',
    ComposeNow: 'compose_now',
    Excluded: 'excluded',
    Duplicate: 'duplicate'
} as const;

export type SentenceAvailableTransitionsEnum = typeof SentenceAvailableTransitionsEnum[keyof typeof SentenceAvailableTransitionsEnum];


/**
 * Connectivity Statement
 * @export
 * @interface SentenceConnectivityStatement
 */
export interface SentenceConnectivityStatement {
    /**
     * 
     * @type {number}
     * @memberof SentenceConnectivityStatement
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof SentenceConnectivityStatement
     */
    'sentence_id': number;
    /**
     * 
     * @type {string}
     * @memberof SentenceConnectivityStatement
     */
    'knowledge_statement': string;
    /**
     * 
     * @type {Array<Doi>}
     * @memberof SentenceConnectivityStatement
     */
    'dois': Array<Doi>;
    /**
     * 
     * @type {number}
     * @memberof SentenceConnectivityStatement
     */
    'ans_division_id': number;
    /**
     * 
     * @type {AnsDivision}
     * @memberof SentenceConnectivityStatement
     */
    'ans_division': AnsDivision;
    /**
     * 
     * @type {LateralityEnum}
     * @memberof SentenceConnectivityStatement
     */
    'laterality': LateralityEnum;
    /**
     * 
     * @type {CircuitTypeEnum}
     * @memberof SentenceConnectivityStatement
     */
    'circuit_type': CircuitTypeEnum;
    /**
     * 
     * @type {Array<Specie>}
     * @memberof SentenceConnectivityStatement
     */
    'species': Array<Specie>;
    /**
     * 
     * @type {number}
     * @memberof SentenceConnectivityStatement
     */
    'biological_sex_id': number;
    /**
     * 
     * @type {BiologicalSex}
     * @memberof SentenceConnectivityStatement
     */
    'biological_sex': BiologicalSex;
    /**
     * 
     * @type {string}
     * @memberof SentenceConnectivityStatement
     */
    'apinatomy_model': string | null;
}
/**
 * Specie
 * @export
 * @interface Specie
 */
export interface Specie {
    /**
     * 
     * @type {number}
     * @memberof Specie
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Specie
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Specie
     */
    'ontology_uri': string;
}
/**
 * Note Tag
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * 
     * @type {number}
     * @memberof Tag
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    'tag': string;
}
/**
 * User
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'id': number;
    /**
     * Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
     * @type {string}
     * @memberof User
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email'?: string;
}
/**
 * Via
 * @export
 * @interface Via
 */
export interface Via {
    /**
     * 
     * @type {number}
     * @memberof Via
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof Via
     */
    'display_order'?: number;
    /**
     * 
     * @type {number}
     * @memberof Via
     */
    'connectivity_statement_id': number;
    /**
     * 
     * @type {AnatomicalEntity}
     * @memberof Via
     */
    'anatomical_entity': AnatomicalEntity;
}

/**
 * ComposerApi - axios parameter creator
 * @export
 */
export const ComposerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * AnatomicalEntity
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerAnatomicalEntityList: async (limit?: number, name?: string, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/composer/anatomical-entity/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * AnatomicalEntity
         * @param {number} id A unique integer value identifying this anatomical entity.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerAnatomicalEntityRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('composerAnatomicalEntityRetrieve', 'id', id)
            const localVarPath = `/api/composer/anatomical-entity/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * AnsDivision
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerAnsDivisionList: async (limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/composer/ans-division/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * AnsDivision
         * @param {number} id A unique integer value identifying this ans division.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerAnsDivisionRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('composerAnsDivisionRetrieve', 'id', id)
            const localVarPath = `/api/composer/ans-division/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * BiologicalSex
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerBiologicalSexList: async (limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/composer/biological-sex/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * BiologicalSex
         * @param {number} id A unique integer value identifying this biological sex.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerBiologicalSexRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('composerBiologicalSexRetrieve', 'id', id)
            const localVarPath = `/api/composer/biological-sex/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ConnectivityStatement
         * @param {number} id A unique integer value identifying this connectivity statement.
         * @param {Array<Doi>} doi 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerConnectivityStatementAddDoisCreate: async (id: number, doi: Array<Doi>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('composerConnectivityStatementAddDoisCreate', 'id', id)
            // verify required parameter 'doi' is not null or undefined
            assertParamExists('composerConnectivityStatementAddDoisCreate', 'doi', doi)
            const localVarPath = `/api/composer/connectivity-statement/{id}/add_dois/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(doi, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ConnectivityStatement
         * @param {number} id A unique integer value identifying this connectivity statement.
         * @param {number} specieId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerConnectivityStatementAddSpecieCreate: async (id: number, specieId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('composerConnectivityStatementAddSpecieCreate', 'id', id)
            // verify required parameter 'specieId' is not null or undefined
            assertParamExists('composerConnectivityStatementAddSpecieCreate', 'specieId', specieId)
            const localVarPath = `/api/composer/connectivity-statement/{id}/add_specie/{specie_id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"specie_id"}}`, encodeURIComponent(String(specieId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ConnectivityStatement
         * @param {number} id A unique integer value identifying this connectivity statement.
         * @param {number} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerConnectivityStatementAddTagCreate: async (id: number, tagId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('composerConnectivityStatementAddTagCreate', 'id', id)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('composerConnectivityStatementAddTagCreate', 'tagId', tagId)
            const localVarPath = `/api/composer/connectivity-statement/{id}/add_tag/{tag_id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"tag_id"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ConnectivityStatement
         * @param {ConnectivityStatement} connectivityStatement 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerConnectivityStatementCreate: async (connectivityStatement: ConnectivityStatement, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectivityStatement' is not null or undefined
            assertParamExists('composerConnectivityStatementCreate', 'connectivityStatement', connectivityStatement)
            const localVarPath = `/api/composer/connectivity-statement/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectivityStatement, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ConnectivityStatement
         * @param {number} doi 
         * @param {number} id A unique integer value identifying this connectivity statement.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerConnectivityStatementDelDoiCreate: async (doi: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'doi' is not null or undefined
            assertParamExists('composerConnectivityStatementDelDoiCreate', 'doi', doi)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('composerConnectivityStatementDelDoiCreate', 'id', id)
            const localVarPath = `/api/composer/connectivity-statement/{id}/del_doi/{doi}/`
                .replace(`{${"doi"}}`, encodeURIComponent(String(doi)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ConnectivityStatement
         * @param {number} id A unique integer value identifying this connectivity statement.
         * @param {number} specieId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerConnectivityStatementDelSpecieCreate: async (id: number, specieId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('composerConnectivityStatementDelSpecieCreate', 'id', id)
            // verify required parameter 'specieId' is not null or undefined
            assertParamExists('composerConnectivityStatementDelSpecieCreate', 'specieId', specieId)
            const localVarPath = `/api/composer/connectivity-statement/{id}/del_specie/{specie_id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"specie_id"}}`, encodeURIComponent(String(specieId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ConnectivityStatement
         * @param {number} id A unique integer value identifying this connectivity statement.
         * @param {number} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerConnectivityStatementDelTagCreate: async (id: number, tagId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('composerConnectivityStatementDelTagCreate', 'id', id)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('composerConnectivityStatementDelTagCreate', 'tagId', tagId)
            const localVarPath = `/api/composer/connectivity-statement/{id}/del_tag/{tag_id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"tag_id"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ConnectivityStatement
         * @param {number} id A unique integer value identifying this connectivity statement.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerConnectivityStatementDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('composerConnectivityStatementDestroy', 'id', id)
            const localVarPath = `/api/composer/connectivity-statement/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ConnectivityStatement
         * @param {number} id A unique integer value identifying this connectivity statement.
         * @param {string} transition 
         * @param {ConnectivityStatement} connectivityStatement 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerConnectivityStatementDoTransitionCreate: async (id: number, transition: string, connectivityStatement: ConnectivityStatement, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('composerConnectivityStatementDoTransitionCreate', 'id', id)
            // verify required parameter 'transition' is not null or undefined
            assertParamExists('composerConnectivityStatementDoTransitionCreate', 'transition', transition)
            // verify required parameter 'connectivityStatement' is not null or undefined
            assertParamExists('composerConnectivityStatementDoTransitionCreate', 'connectivityStatement', connectivityStatement)
            const localVarPath = `/api/composer/connectivity-statement/{id}/do_transition/{transition}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"transition"}}`, encodeURIComponent(String(transition)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectivityStatement, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ConnectivityStatement
         * @param {number} [destination] 
         * @param {string} [knowledgeStatement] 
         * @param {number} [limit] Number of results to return per page.
         * @param {boolean} [notes] Checks if entity has notes
         * @param {number} [offset] The initial index from which to return the results.
         * @param {Array<'-last_edited' | '-pmid' | 'last_edited' | 'pmid'>} [ordering] Ordering
         * @param {number} [origin] 
         * @param {number} [sentenceId] 
         * @param {Array<'approved' | 'compose_now' | 'connection_missing' | 'curated' | 'draft' | 'excluded' | 'npo_approved' | 'rejected' | 'to_be_reviewed'>} [state] 
         * @param {Array<number>} [tags] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerConnectivityStatementList: async (destination?: number, knowledgeStatement?: string, limit?: number, notes?: boolean, offset?: number, ordering?: Array<'-last_edited' | '-pmid' | 'last_edited' | 'pmid'>, origin?: number, sentenceId?: number, state?: Array<'approved' | 'compose_now' | 'connection_missing' | 'curated' | 'draft' | 'excluded' | 'npo_approved' | 'rejected' | 'to_be_reviewed'>, tags?: Array<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/composer/connectivity-statement/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (destination !== undefined) {
                localVarQueryParameter['destination'] = destination;
            }

            if (knowledgeStatement !== undefined) {
                localVarQueryParameter['knowledge_statement'] = knowledgeStatement;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (notes !== undefined) {
                localVarQueryParameter['notes'] = notes;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering) {
                localVarQueryParameter['ordering'] = ordering.join(COLLECTION_FORMATS.csv);
            }

            if (origin !== undefined) {
                localVarQueryParameter['origin'] = origin;
            }

            if (sentenceId !== undefined) {
                localVarQueryParameter['sentence_id'] = sentenceId;
            }

            if (state) {
                localVarQueryParameter['state'] = state;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ConnectivityStatement
         * @param {number} id A unique integer value identifying this connectivity statement.
         * @param {PatchedConnectivityStatement} [patchedConnectivityStatement] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerConnectivityStatementPartialUpdate: async (id: number, patchedConnectivityStatement?: PatchedConnectivityStatement, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('composerConnectivityStatementPartialUpdate', 'id', id)
            const localVarPath = `/api/composer/connectivity-statement/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedConnectivityStatement, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ConnectivityStatement
         * @param {number} id A unique integer value identifying this connectivity statement.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerConnectivityStatementRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('composerConnectivityStatementRetrieve', 'id', id)
            const localVarPath = `/api/composer/connectivity-statement/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ConnectivityStatement
         * @param {number} id A unique integer value identifying this connectivity statement.
         * @param {ConnectivityStatement} connectivityStatement 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerConnectivityStatementUpdate: async (id: number, connectivityStatement: ConnectivityStatement, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('composerConnectivityStatementUpdate', 'id', id)
            // verify required parameter 'connectivityStatement' is not null or undefined
            assertParamExists('composerConnectivityStatementUpdate', 'connectivityStatement', connectivityStatement)
            const localVarPath = `/api/composer/connectivity-statement/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectivityStatement, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerJsonschemasRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/composer/jsonschemas/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Note
         * @param {Note} note 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerNoteCreate: async (note: Note, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'note' is not null or undefined
            assertParamExists('composerNoteCreate', 'note', note)
            const localVarPath = `/api/composer/note/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(note, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Note
         * @param {number} id A unique integer value identifying this note.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerNoteDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('composerNoteDestroy', 'id', id)
            const localVarPath = `/api/composer/note/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Note
         * @param {number} [connectivityStatementId] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {number} [sentenceId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerNoteList: async (connectivityStatementId?: number, limit?: number, offset?: number, sentenceId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/composer/note/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (connectivityStatementId !== undefined) {
                localVarQueryParameter['connectivity_statement_id'] = connectivityStatementId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sentenceId !== undefined) {
                localVarQueryParameter['sentence_id'] = sentenceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Note
         * @param {number} id A unique integer value identifying this note.
         * @param {PatchedNote} [patchedNote] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerNotePartialUpdate: async (id: number, patchedNote?: PatchedNote, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('composerNotePartialUpdate', 'id', id)
            const localVarPath = `/api/composer/note/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedNote, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Note
         * @param {number} id A unique integer value identifying this note.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerNoteRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('composerNoteRetrieve', 'id', id)
            const localVarPath = `/api/composer/note/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Tag
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerNoteTagList: async (limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/composer/note-tag/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Tag
         * @param {number} id A unique integer value identifying this tag.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerNoteTagRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('composerNoteTagRetrieve', 'id', id)
            const localVarPath = `/api/composer/note-tag/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Note
         * @param {number} id A unique integer value identifying this note.
         * @param {Note} note 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerNoteUpdate: async (id: number, note: Note, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('composerNoteUpdate', 'id', id)
            // verify required parameter 'note' is not null or undefined
            assertParamExists('composerNoteUpdate', 'note', note)
            const localVarPath = `/api/composer/note/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(note, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerProfileMyRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/composer/profile/my/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sentence
         * @param {number} id A unique integer value identifying this sentence.
         * @param {number} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerSentenceAddTagCreate: async (id: number, tagId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('composerSentenceAddTagCreate', 'id', id)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('composerSentenceAddTagCreate', 'tagId', tagId)
            const localVarPath = `/api/composer/sentence/{id}/add_tag/{tag_id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"tag_id"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sentence
         * @param {Sentence} sentence 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerSentenceCreate: async (sentence: Sentence, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sentence' is not null or undefined
            assertParamExists('composerSentenceCreate', 'sentence', sentence)
            const localVarPath = `/api/composer/sentence/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sentence, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sentence
         * @param {number} id A unique integer value identifying this sentence.
         * @param {number} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerSentenceDelTagCreate: async (id: number, tagId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('composerSentenceDelTagCreate', 'id', id)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('composerSentenceDelTagCreate', 'tagId', tagId)
            const localVarPath = `/api/composer/sentence/{id}/del_tag/{tag_id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"tag_id"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sentence
         * @param {number} id A unique integer value identifying this sentence.
         * @param {string} transition 
         * @param {Sentence} sentence 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerSentenceDoTransitionCreate: async (id: number, transition: string, sentence: Sentence, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('composerSentenceDoTransitionCreate', 'id', id)
            // verify required parameter 'transition' is not null or undefined
            assertParamExists('composerSentenceDoTransitionCreate', 'transition', transition)
            // verify required parameter 'sentence' is not null or undefined
            assertParamExists('composerSentenceDoTransitionCreate', 'sentence', sentence)
            const localVarPath = `/api/composer/sentence/{id}/do_transition/{transition}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"transition"}}`, encodeURIComponent(String(transition)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sentence, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sentence
         * @param {number} [limit] Number of results to return per page.
         * @param {boolean} [notes] Checks if entity has notes
         * @param {number} [offset] The initial index from which to return the results.
         * @param {Array<'-last_edited' | '-pmid' | 'last_edited' | 'pmid'>} [ordering] Ordering
         * @param {Array<'compose_later' | 'compose_now' | 'duplicate' | 'excluded' | 'open' | 'to_be_reviewed'>} [state] 
         * @param {Array<number>} [tags] 
         * @param {string} [title] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerSentenceList: async (limit?: number, notes?: boolean, offset?: number, ordering?: Array<'-last_edited' | '-pmid' | 'last_edited' | 'pmid'>, state?: Array<'compose_later' | 'compose_now' | 'duplicate' | 'excluded' | 'open' | 'to_be_reviewed'>, tags?: Array<number>, title?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/composer/sentence/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (notes !== undefined) {
                localVarQueryParameter['notes'] = notes;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering) {
                localVarQueryParameter['ordering'] = ordering.join(COLLECTION_FORMATS.csv);
            }

            if (state) {
                localVarQueryParameter['state'] = state;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sentence
         * @param {number} id A unique integer value identifying this sentence.
         * @param {PatchedSentence} [patchedSentence] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerSentencePartialUpdate: async (id: number, patchedSentence?: PatchedSentence, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('composerSentencePartialUpdate', 'id', id)
            const localVarPath = `/api/composer/sentence/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedSentence, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sentence
         * @param {number} id A unique integer value identifying this sentence.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerSentenceRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('composerSentenceRetrieve', 'id', id)
            const localVarPath = `/api/composer/sentence/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sentence
         * @param {number} id A unique integer value identifying this sentence.
         * @param {Sentence} sentence 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerSentenceUpdate: async (id: number, sentence: Sentence, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('composerSentenceUpdate', 'id', id)
            // verify required parameter 'sentence' is not null or undefined
            assertParamExists('composerSentenceUpdate', 'sentence', sentence)
            const localVarPath = `/api/composer/sentence/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sentence, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Specie
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerSpecieList: async (limit?: number, name?: string, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/composer/specie/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Specie
         * @param {number} id A unique integer value identifying this specie.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerSpecieRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('composerSpecieRetrieve', 'id', id)
            const localVarPath = `/api/composer/specie/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Tag
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerTagList: async (limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/composer/tag/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Tag
         * @param {number} id A unique integer value identifying this tag.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerTagRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('composerTagRetrieve', 'id', id)
            const localVarPath = `/api/composer/tag/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Via
         * @param {Via} via 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerViaCreate: async (via: Via, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'via' is not null or undefined
            assertParamExists('composerViaCreate', 'via', via)
            const localVarPath = `/api/composer/via/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(via, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Via
         * @param {number} id A unique integer value identifying this via.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerViaDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('composerViaDestroy', 'id', id)
            const localVarPath = `/api/composer/via/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Via
         * @param {number} [connectivityStatementId] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerViaList: async (connectivityStatementId?: number, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/composer/via/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (connectivityStatementId !== undefined) {
                localVarQueryParameter['connectivity_statement_id'] = connectivityStatementId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Via
         * @param {number} id A unique integer value identifying this via.
         * @param {PatchedVia} [patchedVia] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerViaPartialUpdate: async (id: number, patchedVia?: PatchedVia, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('composerViaPartialUpdate', 'id', id)
            const localVarPath = `/api/composer/via/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedVia, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Via
         * @param {number} id A unique integer value identifying this via.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerViaRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('composerViaRetrieve', 'id', id)
            const localVarPath = `/api/composer/via/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Via
         * @param {number} id A unique integer value identifying this via.
         * @param {Via} via 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerViaUpdate: async (id: number, via: Via, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('composerViaUpdate', 'id', id)
            // verify required parameter 'via' is not null or undefined
            assertParamExists('composerViaUpdate', 'via', via)
            const localVarPath = `/api/composer/via/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(via, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ComposerApi - functional programming interface
 * @export
 */
export const ComposerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ComposerApiAxiosParamCreator(configuration)
    return {
        /**
         * AnatomicalEntity
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async composerAnatomicalEntityList(limit?: number, name?: string, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedAnatomicalEntityList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.composerAnatomicalEntityList(limit, name, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * AnatomicalEntity
         * @param {number} id A unique integer value identifying this anatomical entity.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async composerAnatomicalEntityRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnatomicalEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.composerAnatomicalEntityRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * AnsDivision
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async composerAnsDivisionList(limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedAnsDivisionList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.composerAnsDivisionList(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * AnsDivision
         * @param {number} id A unique integer value identifying this ans division.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async composerAnsDivisionRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnsDivision>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.composerAnsDivisionRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * BiologicalSex
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async composerBiologicalSexList(limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBiologicalSexList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.composerBiologicalSexList(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * BiologicalSex
         * @param {number} id A unique integer value identifying this biological sex.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async composerBiologicalSexRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BiologicalSex>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.composerBiologicalSexRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ConnectivityStatement
         * @param {number} id A unique integer value identifying this connectivity statement.
         * @param {Array<Doi>} doi 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async composerConnectivityStatementAddDoisCreate(id: number, doi: Array<Doi>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectivityStatement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.composerConnectivityStatementAddDoisCreate(id, doi, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ConnectivityStatement
         * @param {number} id A unique integer value identifying this connectivity statement.
         * @param {number} specieId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async composerConnectivityStatementAddSpecieCreate(id: number, specieId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectivityStatement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.composerConnectivityStatementAddSpecieCreate(id, specieId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ConnectivityStatement
         * @param {number} id A unique integer value identifying this connectivity statement.
         * @param {number} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async composerConnectivityStatementAddTagCreate(id: number, tagId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectivityStatement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.composerConnectivityStatementAddTagCreate(id, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ConnectivityStatement
         * @param {ConnectivityStatement} connectivityStatement 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async composerConnectivityStatementCreate(connectivityStatement: ConnectivityStatement, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectivityStatement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.composerConnectivityStatementCreate(connectivityStatement, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ConnectivityStatement
         * @param {number} doi 
         * @param {number} id A unique integer value identifying this connectivity statement.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async composerConnectivityStatementDelDoiCreate(doi: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectivityStatement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.composerConnectivityStatementDelDoiCreate(doi, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ConnectivityStatement
         * @param {number} id A unique integer value identifying this connectivity statement.
         * @param {number} specieId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async composerConnectivityStatementDelSpecieCreate(id: number, specieId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectivityStatement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.composerConnectivityStatementDelSpecieCreate(id, specieId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ConnectivityStatement
         * @param {number} id A unique integer value identifying this connectivity statement.
         * @param {number} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async composerConnectivityStatementDelTagCreate(id: number, tagId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectivityStatement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.composerConnectivityStatementDelTagCreate(id, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ConnectivityStatement
         * @param {number} id A unique integer value identifying this connectivity statement.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async composerConnectivityStatementDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.composerConnectivityStatementDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ConnectivityStatement
         * @param {number} id A unique integer value identifying this connectivity statement.
         * @param {string} transition 
         * @param {ConnectivityStatement} connectivityStatement 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async composerConnectivityStatementDoTransitionCreate(id: number, transition: string, connectivityStatement: ConnectivityStatement, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectivityStatement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.composerConnectivityStatementDoTransitionCreate(id, transition, connectivityStatement, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ConnectivityStatement
         * @param {number} [destination] 
         * @param {string} [knowledgeStatement] 
         * @param {number} [limit] Number of results to return per page.
         * @param {boolean} [notes] Checks if entity has notes
         * @param {number} [offset] The initial index from which to return the results.
         * @param {Array<'-last_edited' | '-pmid' | 'last_edited' | 'pmid'>} [ordering] Ordering
         * @param {number} [origin] 
         * @param {number} [sentenceId] 
         * @param {Array<'approved' | 'compose_now' | 'connection_missing' | 'curated' | 'draft' | 'excluded' | 'npo_approved' | 'rejected' | 'to_be_reviewed'>} [state] 
         * @param {Array<number>} [tags] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async composerConnectivityStatementList(destination?: number, knowledgeStatement?: string, limit?: number, notes?: boolean, offset?: number, ordering?: Array<'-last_edited' | '-pmid' | 'last_edited' | 'pmid'>, origin?: number, sentenceId?: number, state?: Array<'approved' | 'compose_now' | 'connection_missing' | 'curated' | 'draft' | 'excluded' | 'npo_approved' | 'rejected' | 'to_be_reviewed'>, tags?: Array<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedConnectivityStatementList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.composerConnectivityStatementList(destination, knowledgeStatement, limit, notes, offset, ordering, origin, sentenceId, state, tags, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ConnectivityStatement
         * @param {number} id A unique integer value identifying this connectivity statement.
         * @param {PatchedConnectivityStatement} [patchedConnectivityStatement] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async composerConnectivityStatementPartialUpdate(id: number, patchedConnectivityStatement?: PatchedConnectivityStatement, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectivityStatement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.composerConnectivityStatementPartialUpdate(id, patchedConnectivityStatement, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ConnectivityStatement
         * @param {number} id A unique integer value identifying this connectivity statement.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async composerConnectivityStatementRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectivityStatement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.composerConnectivityStatementRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ConnectivityStatement
         * @param {number} id A unique integer value identifying this connectivity statement.
         * @param {ConnectivityStatement} connectivityStatement 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async composerConnectivityStatementUpdate(id: number, connectivityStatement: ConnectivityStatement, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectivityStatement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.composerConnectivityStatementUpdate(id, connectivityStatement, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async composerJsonschemasRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.composerJsonschemasRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Note
         * @param {Note} note 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async composerNoteCreate(note: Note, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Note>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.composerNoteCreate(note, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Note
         * @param {number} id A unique integer value identifying this note.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async composerNoteDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.composerNoteDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Note
         * @param {number} [connectivityStatementId] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {number} [sentenceId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async composerNoteList(connectivityStatementId?: number, limit?: number, offset?: number, sentenceId?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedNoteList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.composerNoteList(connectivityStatementId, limit, offset, sentenceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Note
         * @param {number} id A unique integer value identifying this note.
         * @param {PatchedNote} [patchedNote] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async composerNotePartialUpdate(id: number, patchedNote?: PatchedNote, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Note>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.composerNotePartialUpdate(id, patchedNote, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Note
         * @param {number} id A unique integer value identifying this note.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async composerNoteRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Note>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.composerNoteRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Tag
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async composerNoteTagList(limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedTagList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.composerNoteTagList(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Tag
         * @param {number} id A unique integer value identifying this tag.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async composerNoteTagRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.composerNoteTagRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Note
         * @param {number} id A unique integer value identifying this note.
         * @param {Note} note 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async composerNoteUpdate(id: number, note: Note, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Note>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.composerNoteUpdate(id, note, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async composerProfileMyRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Profile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.composerProfileMyRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sentence
         * @param {number} id A unique integer value identifying this sentence.
         * @param {number} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async composerSentenceAddTagCreate(id: number, tagId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sentence>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.composerSentenceAddTagCreate(id, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sentence
         * @param {Sentence} sentence 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async composerSentenceCreate(sentence: Sentence, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sentence>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.composerSentenceCreate(sentence, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sentence
         * @param {number} id A unique integer value identifying this sentence.
         * @param {number} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async composerSentenceDelTagCreate(id: number, tagId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sentence>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.composerSentenceDelTagCreate(id, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sentence
         * @param {number} id A unique integer value identifying this sentence.
         * @param {string} transition 
         * @param {Sentence} sentence 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async composerSentenceDoTransitionCreate(id: number, transition: string, sentence: Sentence, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sentence>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.composerSentenceDoTransitionCreate(id, transition, sentence, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sentence
         * @param {number} [limit] Number of results to return per page.
         * @param {boolean} [notes] Checks if entity has notes
         * @param {number} [offset] The initial index from which to return the results.
         * @param {Array<'-last_edited' | '-pmid' | 'last_edited' | 'pmid'>} [ordering] Ordering
         * @param {Array<'compose_later' | 'compose_now' | 'duplicate' | 'excluded' | 'open' | 'to_be_reviewed'>} [state] 
         * @param {Array<number>} [tags] 
         * @param {string} [title] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async composerSentenceList(limit?: number, notes?: boolean, offset?: number, ordering?: Array<'-last_edited' | '-pmid' | 'last_edited' | 'pmid'>, state?: Array<'compose_later' | 'compose_now' | 'duplicate' | 'excluded' | 'open' | 'to_be_reviewed'>, tags?: Array<number>, title?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSentenceList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.composerSentenceList(limit, notes, offset, ordering, state, tags, title, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sentence
         * @param {number} id A unique integer value identifying this sentence.
         * @param {PatchedSentence} [patchedSentence] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async composerSentencePartialUpdate(id: number, patchedSentence?: PatchedSentence, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sentence>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.composerSentencePartialUpdate(id, patchedSentence, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sentence
         * @param {number} id A unique integer value identifying this sentence.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async composerSentenceRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sentence>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.composerSentenceRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sentence
         * @param {number} id A unique integer value identifying this sentence.
         * @param {Sentence} sentence 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async composerSentenceUpdate(id: number, sentence: Sentence, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sentence>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.composerSentenceUpdate(id, sentence, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Specie
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async composerSpecieList(limit?: number, name?: string, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSpecieList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.composerSpecieList(limit, name, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Specie
         * @param {number} id A unique integer value identifying this specie.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async composerSpecieRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Specie>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.composerSpecieRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Tag
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async composerTagList(limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedTagList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.composerTagList(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Tag
         * @param {number} id A unique integer value identifying this tag.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async composerTagRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.composerTagRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Via
         * @param {Via} via 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async composerViaCreate(via: Via, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Via>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.composerViaCreate(via, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Via
         * @param {number} id A unique integer value identifying this via.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async composerViaDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.composerViaDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Via
         * @param {number} [connectivityStatementId] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async composerViaList(connectivityStatementId?: number, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedViaList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.composerViaList(connectivityStatementId, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Via
         * @param {number} id A unique integer value identifying this via.
         * @param {PatchedVia} [patchedVia] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async composerViaPartialUpdate(id: number, patchedVia?: PatchedVia, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Via>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.composerViaPartialUpdate(id, patchedVia, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Via
         * @param {number} id A unique integer value identifying this via.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async composerViaRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Via>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.composerViaRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Via
         * @param {number} id A unique integer value identifying this via.
         * @param {Via} via 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async composerViaUpdate(id: number, via: Via, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Via>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.composerViaUpdate(id, via, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ComposerApi - factory interface
 * @export
 */
export const ComposerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ComposerApiFp(configuration)
    return {
        /**
         * AnatomicalEntity
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerAnatomicalEntityList(limit?: number, name?: string, offset?: number, options?: any): AxiosPromise<PaginatedAnatomicalEntityList> {
            return localVarFp.composerAnatomicalEntityList(limit, name, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * AnatomicalEntity
         * @param {number} id A unique integer value identifying this anatomical entity.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerAnatomicalEntityRetrieve(id: number, options?: any): AxiosPromise<AnatomicalEntity> {
            return localVarFp.composerAnatomicalEntityRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * AnsDivision
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerAnsDivisionList(limit?: number, offset?: number, options?: any): AxiosPromise<PaginatedAnsDivisionList> {
            return localVarFp.composerAnsDivisionList(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * AnsDivision
         * @param {number} id A unique integer value identifying this ans division.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerAnsDivisionRetrieve(id: number, options?: any): AxiosPromise<AnsDivision> {
            return localVarFp.composerAnsDivisionRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * BiologicalSex
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerBiologicalSexList(limit?: number, offset?: number, options?: any): AxiosPromise<PaginatedBiologicalSexList> {
            return localVarFp.composerBiologicalSexList(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * BiologicalSex
         * @param {number} id A unique integer value identifying this biological sex.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerBiologicalSexRetrieve(id: number, options?: any): AxiosPromise<BiologicalSex> {
            return localVarFp.composerBiologicalSexRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ConnectivityStatement
         * @param {number} id A unique integer value identifying this connectivity statement.
         * @param {Array<Doi>} doi 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerConnectivityStatementAddDoisCreate(id: number, doi: Array<Doi>, options?: any): AxiosPromise<ConnectivityStatement> {
            return localVarFp.composerConnectivityStatementAddDoisCreate(id, doi, options).then((request) => request(axios, basePath));
        },
        /**
         * ConnectivityStatement
         * @param {number} id A unique integer value identifying this connectivity statement.
         * @param {number} specieId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerConnectivityStatementAddSpecieCreate(id: number, specieId: number, options?: any): AxiosPromise<ConnectivityStatement> {
            return localVarFp.composerConnectivityStatementAddSpecieCreate(id, specieId, options).then((request) => request(axios, basePath));
        },
        /**
         * ConnectivityStatement
         * @param {number} id A unique integer value identifying this connectivity statement.
         * @param {number} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerConnectivityStatementAddTagCreate(id: number, tagId: number, options?: any): AxiosPromise<ConnectivityStatement> {
            return localVarFp.composerConnectivityStatementAddTagCreate(id, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * ConnectivityStatement
         * @param {ConnectivityStatement} connectivityStatement 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerConnectivityStatementCreate(connectivityStatement: ConnectivityStatement, options?: any): AxiosPromise<ConnectivityStatement> {
            return localVarFp.composerConnectivityStatementCreate(connectivityStatement, options).then((request) => request(axios, basePath));
        },
        /**
         * ConnectivityStatement
         * @param {number} doi 
         * @param {number} id A unique integer value identifying this connectivity statement.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerConnectivityStatementDelDoiCreate(doi: number, id: number, options?: any): AxiosPromise<ConnectivityStatement> {
            return localVarFp.composerConnectivityStatementDelDoiCreate(doi, id, options).then((request) => request(axios, basePath));
        },
        /**
         * ConnectivityStatement
         * @param {number} id A unique integer value identifying this connectivity statement.
         * @param {number} specieId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerConnectivityStatementDelSpecieCreate(id: number, specieId: number, options?: any): AxiosPromise<ConnectivityStatement> {
            return localVarFp.composerConnectivityStatementDelSpecieCreate(id, specieId, options).then((request) => request(axios, basePath));
        },
        /**
         * ConnectivityStatement
         * @param {number} id A unique integer value identifying this connectivity statement.
         * @param {number} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerConnectivityStatementDelTagCreate(id: number, tagId: number, options?: any): AxiosPromise<ConnectivityStatement> {
            return localVarFp.composerConnectivityStatementDelTagCreate(id, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * ConnectivityStatement
         * @param {number} id A unique integer value identifying this connectivity statement.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerConnectivityStatementDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.composerConnectivityStatementDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ConnectivityStatement
         * @param {number} id A unique integer value identifying this connectivity statement.
         * @param {string} transition 
         * @param {ConnectivityStatement} connectivityStatement 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerConnectivityStatementDoTransitionCreate(id: number, transition: string, connectivityStatement: ConnectivityStatement, options?: any): AxiosPromise<ConnectivityStatement> {
            return localVarFp.composerConnectivityStatementDoTransitionCreate(id, transition, connectivityStatement, options).then((request) => request(axios, basePath));
        },
        /**
         * ConnectivityStatement
         * @param {number} [destination] 
         * @param {string} [knowledgeStatement] 
         * @param {number} [limit] Number of results to return per page.
         * @param {boolean} [notes] Checks if entity has notes
         * @param {number} [offset] The initial index from which to return the results.
         * @param {Array<'-last_edited' | '-pmid' | 'last_edited' | 'pmid'>} [ordering] Ordering
         * @param {number} [origin] 
         * @param {number} [sentenceId] 
         * @param {Array<'approved' | 'compose_now' | 'connection_missing' | 'curated' | 'draft' | 'excluded' | 'npo_approved' | 'rejected' | 'to_be_reviewed'>} [state] 
         * @param {Array<number>} [tags] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerConnectivityStatementList(destination?: number, knowledgeStatement?: string, limit?: number, notes?: boolean, offset?: number, ordering?: Array<'-last_edited' | '-pmid' | 'last_edited' | 'pmid'>, origin?: number, sentenceId?: number, state?: Array<'approved' | 'compose_now' | 'connection_missing' | 'curated' | 'draft' | 'excluded' | 'npo_approved' | 'rejected' | 'to_be_reviewed'>, tags?: Array<number>, options?: any): AxiosPromise<PaginatedConnectivityStatementList> {
            return localVarFp.composerConnectivityStatementList(destination, knowledgeStatement, limit, notes, offset, ordering, origin, sentenceId, state, tags, options).then((request) => request(axios, basePath));
        },
        /**
         * ConnectivityStatement
         * @param {number} id A unique integer value identifying this connectivity statement.
         * @param {PatchedConnectivityStatement} [patchedConnectivityStatement] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerConnectivityStatementPartialUpdate(id: number, patchedConnectivityStatement?: PatchedConnectivityStatement, options?: any): AxiosPromise<ConnectivityStatement> {
            return localVarFp.composerConnectivityStatementPartialUpdate(id, patchedConnectivityStatement, options).then((request) => request(axios, basePath));
        },
        /**
         * ConnectivityStatement
         * @param {number} id A unique integer value identifying this connectivity statement.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerConnectivityStatementRetrieve(id: number, options?: any): AxiosPromise<ConnectivityStatement> {
            return localVarFp.composerConnectivityStatementRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ConnectivityStatement
         * @param {number} id A unique integer value identifying this connectivity statement.
         * @param {ConnectivityStatement} connectivityStatement 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerConnectivityStatementUpdate(id: number, connectivityStatement: ConnectivityStatement, options?: any): AxiosPromise<ConnectivityStatement> {
            return localVarFp.composerConnectivityStatementUpdate(id, connectivityStatement, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerJsonschemasRetrieve(options?: any): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.composerJsonschemasRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * Note
         * @param {Note} note 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerNoteCreate(note: Note, options?: any): AxiosPromise<Note> {
            return localVarFp.composerNoteCreate(note, options).then((request) => request(axios, basePath));
        },
        /**
         * Note
         * @param {number} id A unique integer value identifying this note.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerNoteDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.composerNoteDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Note
         * @param {number} [connectivityStatementId] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {number} [sentenceId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerNoteList(connectivityStatementId?: number, limit?: number, offset?: number, sentenceId?: number, options?: any): AxiosPromise<PaginatedNoteList> {
            return localVarFp.composerNoteList(connectivityStatementId, limit, offset, sentenceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Note
         * @param {number} id A unique integer value identifying this note.
         * @param {PatchedNote} [patchedNote] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerNotePartialUpdate(id: number, patchedNote?: PatchedNote, options?: any): AxiosPromise<Note> {
            return localVarFp.composerNotePartialUpdate(id, patchedNote, options).then((request) => request(axios, basePath));
        },
        /**
         * Note
         * @param {number} id A unique integer value identifying this note.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerNoteRetrieve(id: number, options?: any): AxiosPromise<Note> {
            return localVarFp.composerNoteRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Tag
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerNoteTagList(limit?: number, offset?: number, options?: any): AxiosPromise<PaginatedTagList> {
            return localVarFp.composerNoteTagList(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Tag
         * @param {number} id A unique integer value identifying this tag.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerNoteTagRetrieve(id: number, options?: any): AxiosPromise<Tag> {
            return localVarFp.composerNoteTagRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Note
         * @param {number} id A unique integer value identifying this note.
         * @param {Note} note 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerNoteUpdate(id: number, note: Note, options?: any): AxiosPromise<Note> {
            return localVarFp.composerNoteUpdate(id, note, options).then((request) => request(axios, basePath));
        },
        /**
         * Profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerProfileMyRetrieve(options?: any): AxiosPromise<Profile> {
            return localVarFp.composerProfileMyRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * Sentence
         * @param {number} id A unique integer value identifying this sentence.
         * @param {number} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerSentenceAddTagCreate(id: number, tagId: number, options?: any): AxiosPromise<Sentence> {
            return localVarFp.composerSentenceAddTagCreate(id, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Sentence
         * @param {Sentence} sentence 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerSentenceCreate(sentence: Sentence, options?: any): AxiosPromise<Sentence> {
            return localVarFp.composerSentenceCreate(sentence, options).then((request) => request(axios, basePath));
        },
        /**
         * Sentence
         * @param {number} id A unique integer value identifying this sentence.
         * @param {number} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerSentenceDelTagCreate(id: number, tagId: number, options?: any): AxiosPromise<Sentence> {
            return localVarFp.composerSentenceDelTagCreate(id, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Sentence
         * @param {number} id A unique integer value identifying this sentence.
         * @param {string} transition 
         * @param {Sentence} sentence 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerSentenceDoTransitionCreate(id: number, transition: string, sentence: Sentence, options?: any): AxiosPromise<Sentence> {
            return localVarFp.composerSentenceDoTransitionCreate(id, transition, sentence, options).then((request) => request(axios, basePath));
        },
        /**
         * Sentence
         * @param {number} [limit] Number of results to return per page.
         * @param {boolean} [notes] Checks if entity has notes
         * @param {number} [offset] The initial index from which to return the results.
         * @param {Array<'-last_edited' | '-pmid' | 'last_edited' | 'pmid'>} [ordering] Ordering
         * @param {Array<'compose_later' | 'compose_now' | 'duplicate' | 'excluded' | 'open' | 'to_be_reviewed'>} [state] 
         * @param {Array<number>} [tags] 
         * @param {string} [title] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerSentenceList(limit?: number, notes?: boolean, offset?: number, ordering?: Array<'-last_edited' | '-pmid' | 'last_edited' | 'pmid'>, state?: Array<'compose_later' | 'compose_now' | 'duplicate' | 'excluded' | 'open' | 'to_be_reviewed'>, tags?: Array<number>, title?: string, options?: any): AxiosPromise<PaginatedSentenceList> {
            return localVarFp.composerSentenceList(limit, notes, offset, ordering, state, tags, title, options).then((request) => request(axios, basePath));
        },
        /**
         * Sentence
         * @param {number} id A unique integer value identifying this sentence.
         * @param {PatchedSentence} [patchedSentence] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerSentencePartialUpdate(id: number, patchedSentence?: PatchedSentence, options?: any): AxiosPromise<Sentence> {
            return localVarFp.composerSentencePartialUpdate(id, patchedSentence, options).then((request) => request(axios, basePath));
        },
        /**
         * Sentence
         * @param {number} id A unique integer value identifying this sentence.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerSentenceRetrieve(id: number, options?: any): AxiosPromise<Sentence> {
            return localVarFp.composerSentenceRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Sentence
         * @param {number} id A unique integer value identifying this sentence.
         * @param {Sentence} sentence 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerSentenceUpdate(id: number, sentence: Sentence, options?: any): AxiosPromise<Sentence> {
            return localVarFp.composerSentenceUpdate(id, sentence, options).then((request) => request(axios, basePath));
        },
        /**
         * Specie
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerSpecieList(limit?: number, name?: string, offset?: number, options?: any): AxiosPromise<PaginatedSpecieList> {
            return localVarFp.composerSpecieList(limit, name, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Specie
         * @param {number} id A unique integer value identifying this specie.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerSpecieRetrieve(id: number, options?: any): AxiosPromise<Specie> {
            return localVarFp.composerSpecieRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Tag
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerTagList(limit?: number, offset?: number, options?: any): AxiosPromise<PaginatedTagList> {
            return localVarFp.composerTagList(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Tag
         * @param {number} id A unique integer value identifying this tag.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerTagRetrieve(id: number, options?: any): AxiosPromise<Tag> {
            return localVarFp.composerTagRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Via
         * @param {Via} via 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerViaCreate(via: Via, options?: any): AxiosPromise<Via> {
            return localVarFp.composerViaCreate(via, options).then((request) => request(axios, basePath));
        },
        /**
         * Via
         * @param {number} id A unique integer value identifying this via.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerViaDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.composerViaDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Via
         * @param {number} [connectivityStatementId] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerViaList(connectivityStatementId?: number, limit?: number, offset?: number, options?: any): AxiosPromise<PaginatedViaList> {
            return localVarFp.composerViaList(connectivityStatementId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Via
         * @param {number} id A unique integer value identifying this via.
         * @param {PatchedVia} [patchedVia] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerViaPartialUpdate(id: number, patchedVia?: PatchedVia, options?: any): AxiosPromise<Via> {
            return localVarFp.composerViaPartialUpdate(id, patchedVia, options).then((request) => request(axios, basePath));
        },
        /**
         * Via
         * @param {number} id A unique integer value identifying this via.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerViaRetrieve(id: number, options?: any): AxiosPromise<Via> {
            return localVarFp.composerViaRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Via
         * @param {number} id A unique integer value identifying this via.
         * @param {Via} via 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        composerViaUpdate(id: number, via: Via, options?: any): AxiosPromise<Via> {
            return localVarFp.composerViaUpdate(id, via, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ComposerApi - object-oriented interface
 * @export
 * @class ComposerApi
 * @extends {BaseAPI}
 */
export class ComposerApi extends BaseAPI {
    /**
     * AnatomicalEntity
     * @param {number} [limit] Number of results to return per page.
     * @param {string} [name] 
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComposerApi
     */
    public composerAnatomicalEntityList(limit?: number, name?: string, offset?: number, options?: AxiosRequestConfig) {
        return ComposerApiFp(this.configuration).composerAnatomicalEntityList(limit, name, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * AnatomicalEntity
     * @param {number} id A unique integer value identifying this anatomical entity.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComposerApi
     */
    public composerAnatomicalEntityRetrieve(id: number, options?: AxiosRequestConfig) {
        return ComposerApiFp(this.configuration).composerAnatomicalEntityRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * AnsDivision
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComposerApi
     */
    public composerAnsDivisionList(limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return ComposerApiFp(this.configuration).composerAnsDivisionList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * AnsDivision
     * @param {number} id A unique integer value identifying this ans division.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComposerApi
     */
    public composerAnsDivisionRetrieve(id: number, options?: AxiosRequestConfig) {
        return ComposerApiFp(this.configuration).composerAnsDivisionRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * BiologicalSex
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComposerApi
     */
    public composerBiologicalSexList(limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return ComposerApiFp(this.configuration).composerBiologicalSexList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * BiologicalSex
     * @param {number} id A unique integer value identifying this biological sex.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComposerApi
     */
    public composerBiologicalSexRetrieve(id: number, options?: AxiosRequestConfig) {
        return ComposerApiFp(this.configuration).composerBiologicalSexRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ConnectivityStatement
     * @param {number} id A unique integer value identifying this connectivity statement.
     * @param {Array<Doi>} doi 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComposerApi
     */
    public composerConnectivityStatementAddDoisCreate(id: number, doi: Array<Doi>, options?: AxiosRequestConfig) {
        return ComposerApiFp(this.configuration).composerConnectivityStatementAddDoisCreate(id, doi, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ConnectivityStatement
     * @param {number} id A unique integer value identifying this connectivity statement.
     * @param {number} specieId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComposerApi
     */
    public composerConnectivityStatementAddSpecieCreate(id: number, specieId: number, options?: AxiosRequestConfig) {
        return ComposerApiFp(this.configuration).composerConnectivityStatementAddSpecieCreate(id, specieId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ConnectivityStatement
     * @param {number} id A unique integer value identifying this connectivity statement.
     * @param {number} tagId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComposerApi
     */
    public composerConnectivityStatementAddTagCreate(id: number, tagId: number, options?: AxiosRequestConfig) {
        return ComposerApiFp(this.configuration).composerConnectivityStatementAddTagCreate(id, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ConnectivityStatement
     * @param {ConnectivityStatement} connectivityStatement 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComposerApi
     */
    public composerConnectivityStatementCreate(connectivityStatement: ConnectivityStatement, options?: AxiosRequestConfig) {
        return ComposerApiFp(this.configuration).composerConnectivityStatementCreate(connectivityStatement, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ConnectivityStatement
     * @param {number} doi 
     * @param {number} id A unique integer value identifying this connectivity statement.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComposerApi
     */
    public composerConnectivityStatementDelDoiCreate(doi: number, id: number, options?: AxiosRequestConfig) {
        return ComposerApiFp(this.configuration).composerConnectivityStatementDelDoiCreate(doi, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ConnectivityStatement
     * @param {number} id A unique integer value identifying this connectivity statement.
     * @param {number} specieId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComposerApi
     */
    public composerConnectivityStatementDelSpecieCreate(id: number, specieId: number, options?: AxiosRequestConfig) {
        return ComposerApiFp(this.configuration).composerConnectivityStatementDelSpecieCreate(id, specieId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ConnectivityStatement
     * @param {number} id A unique integer value identifying this connectivity statement.
     * @param {number} tagId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComposerApi
     */
    public composerConnectivityStatementDelTagCreate(id: number, tagId: number, options?: AxiosRequestConfig) {
        return ComposerApiFp(this.configuration).composerConnectivityStatementDelTagCreate(id, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ConnectivityStatement
     * @param {number} id A unique integer value identifying this connectivity statement.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComposerApi
     */
    public composerConnectivityStatementDestroy(id: number, options?: AxiosRequestConfig) {
        return ComposerApiFp(this.configuration).composerConnectivityStatementDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ConnectivityStatement
     * @param {number} id A unique integer value identifying this connectivity statement.
     * @param {string} transition 
     * @param {ConnectivityStatement} connectivityStatement 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComposerApi
     */
    public composerConnectivityStatementDoTransitionCreate(id: number, transition: string, connectivityStatement: ConnectivityStatement, options?: AxiosRequestConfig) {
        return ComposerApiFp(this.configuration).composerConnectivityStatementDoTransitionCreate(id, transition, connectivityStatement, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ConnectivityStatement
     * @param {number} [destination] 
     * @param {string} [knowledgeStatement] 
     * @param {number} [limit] Number of results to return per page.
     * @param {boolean} [notes] Checks if entity has notes
     * @param {number} [offset] The initial index from which to return the results.
     * @param {Array<'-last_edited' | '-pmid' | 'last_edited' | 'pmid'>} [ordering] Ordering
     * @param {number} [origin] 
     * @param {number} [sentenceId] 
     * @param {Array<'approved' | 'compose_now' | 'connection_missing' | 'curated' | 'draft' | 'excluded' | 'npo_approved' | 'rejected' | 'to_be_reviewed'>} [state] 
     * @param {Array<number>} [tags] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComposerApi
     */
    public composerConnectivityStatementList(destination?: number, knowledgeStatement?: string, limit?: number, notes?: boolean, offset?: number, ordering?: Array<'-last_edited' | '-pmid' | 'last_edited' | 'pmid'>, origin?: number, sentenceId?: number, state?: Array<'approved' | 'compose_now' | 'connection_missing' | 'curated' | 'draft' | 'excluded' | 'npo_approved' | 'rejected' | 'to_be_reviewed'>, tags?: Array<number>, options?: AxiosRequestConfig) {
        return ComposerApiFp(this.configuration).composerConnectivityStatementList(destination, knowledgeStatement, limit, notes, offset, ordering, origin, sentenceId, state, tags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ConnectivityStatement
     * @param {number} id A unique integer value identifying this connectivity statement.
     * @param {PatchedConnectivityStatement} [patchedConnectivityStatement] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComposerApi
     */
    public composerConnectivityStatementPartialUpdate(id: number, patchedConnectivityStatement?: PatchedConnectivityStatement, options?: AxiosRequestConfig) {
        return ComposerApiFp(this.configuration).composerConnectivityStatementPartialUpdate(id, patchedConnectivityStatement, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ConnectivityStatement
     * @param {number} id A unique integer value identifying this connectivity statement.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComposerApi
     */
    public composerConnectivityStatementRetrieve(id: number, options?: AxiosRequestConfig) {
        return ComposerApiFp(this.configuration).composerConnectivityStatementRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ConnectivityStatement
     * @param {number} id A unique integer value identifying this connectivity statement.
     * @param {ConnectivityStatement} connectivityStatement 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComposerApi
     */
    public composerConnectivityStatementUpdate(id: number, connectivityStatement: ConnectivityStatement, options?: AxiosRequestConfig) {
        return ComposerApiFp(this.configuration).composerConnectivityStatementUpdate(id, connectivityStatement, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComposerApi
     */
    public composerJsonschemasRetrieve(options?: AxiosRequestConfig) {
        return ComposerApiFp(this.configuration).composerJsonschemasRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Note
     * @param {Note} note 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComposerApi
     */
    public composerNoteCreate(note: Note, options?: AxiosRequestConfig) {
        return ComposerApiFp(this.configuration).composerNoteCreate(note, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Note
     * @param {number} id A unique integer value identifying this note.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComposerApi
     */
    public composerNoteDestroy(id: number, options?: AxiosRequestConfig) {
        return ComposerApiFp(this.configuration).composerNoteDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Note
     * @param {number} [connectivityStatementId] 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {number} [sentenceId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComposerApi
     */
    public composerNoteList(connectivityStatementId?: number, limit?: number, offset?: number, sentenceId?: number, options?: AxiosRequestConfig) {
        return ComposerApiFp(this.configuration).composerNoteList(connectivityStatementId, limit, offset, sentenceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Note
     * @param {number} id A unique integer value identifying this note.
     * @param {PatchedNote} [patchedNote] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComposerApi
     */
    public composerNotePartialUpdate(id: number, patchedNote?: PatchedNote, options?: AxiosRequestConfig) {
        return ComposerApiFp(this.configuration).composerNotePartialUpdate(id, patchedNote, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Note
     * @param {number} id A unique integer value identifying this note.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComposerApi
     */
    public composerNoteRetrieve(id: number, options?: AxiosRequestConfig) {
        return ComposerApiFp(this.configuration).composerNoteRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Tag
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComposerApi
     */
    public composerNoteTagList(limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return ComposerApiFp(this.configuration).composerNoteTagList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Tag
     * @param {number} id A unique integer value identifying this tag.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComposerApi
     */
    public composerNoteTagRetrieve(id: number, options?: AxiosRequestConfig) {
        return ComposerApiFp(this.configuration).composerNoteTagRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Note
     * @param {number} id A unique integer value identifying this note.
     * @param {Note} note 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComposerApi
     */
    public composerNoteUpdate(id: number, note: Note, options?: AxiosRequestConfig) {
        return ComposerApiFp(this.configuration).composerNoteUpdate(id, note, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComposerApi
     */
    public composerProfileMyRetrieve(options?: AxiosRequestConfig) {
        return ComposerApiFp(this.configuration).composerProfileMyRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sentence
     * @param {number} id A unique integer value identifying this sentence.
     * @param {number} tagId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComposerApi
     */
    public composerSentenceAddTagCreate(id: number, tagId: number, options?: AxiosRequestConfig) {
        return ComposerApiFp(this.configuration).composerSentenceAddTagCreate(id, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sentence
     * @param {Sentence} sentence 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComposerApi
     */
    public composerSentenceCreate(sentence: Sentence, options?: AxiosRequestConfig) {
        return ComposerApiFp(this.configuration).composerSentenceCreate(sentence, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sentence
     * @param {number} id A unique integer value identifying this sentence.
     * @param {number} tagId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComposerApi
     */
    public composerSentenceDelTagCreate(id: number, tagId: number, options?: AxiosRequestConfig) {
        return ComposerApiFp(this.configuration).composerSentenceDelTagCreate(id, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sentence
     * @param {number} id A unique integer value identifying this sentence.
     * @param {string} transition 
     * @param {Sentence} sentence 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComposerApi
     */
    public composerSentenceDoTransitionCreate(id: number, transition: string, sentence: Sentence, options?: AxiosRequestConfig) {
        return ComposerApiFp(this.configuration).composerSentenceDoTransitionCreate(id, transition, sentence, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sentence
     * @param {number} [limit] Number of results to return per page.
     * @param {boolean} [notes] Checks if entity has notes
     * @param {number} [offset] The initial index from which to return the results.
     * @param {Array<'-last_edited' | '-pmid' | 'last_edited' | 'pmid'>} [ordering] Ordering
     * @param {Array<'compose_later' | 'compose_now' | 'duplicate' | 'excluded' | 'open' | 'to_be_reviewed'>} [state] 
     * @param {Array<number>} [tags] 
     * @param {string} [title] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComposerApi
     */
    public composerSentenceList(limit?: number, notes?: boolean, offset?: number, ordering?: Array<'-last_edited' | '-pmid' | 'last_edited' | 'pmid'>, state?: Array<'compose_later' | 'compose_now' | 'duplicate' | 'excluded' | 'open' | 'to_be_reviewed'>, tags?: Array<number>, title?: string, options?: AxiosRequestConfig) {
        return ComposerApiFp(this.configuration).composerSentenceList(limit, notes, offset, ordering, state, tags, title, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sentence
     * @param {number} id A unique integer value identifying this sentence.
     * @param {PatchedSentence} [patchedSentence] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComposerApi
     */
    public composerSentencePartialUpdate(id: number, patchedSentence?: PatchedSentence, options?: AxiosRequestConfig) {
        return ComposerApiFp(this.configuration).composerSentencePartialUpdate(id, patchedSentence, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sentence
     * @param {number} id A unique integer value identifying this sentence.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComposerApi
     */
    public composerSentenceRetrieve(id: number, options?: AxiosRequestConfig) {
        return ComposerApiFp(this.configuration).composerSentenceRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sentence
     * @param {number} id A unique integer value identifying this sentence.
     * @param {Sentence} sentence 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComposerApi
     */
    public composerSentenceUpdate(id: number, sentence: Sentence, options?: AxiosRequestConfig) {
        return ComposerApiFp(this.configuration).composerSentenceUpdate(id, sentence, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Specie
     * @param {number} [limit] Number of results to return per page.
     * @param {string} [name] 
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComposerApi
     */
    public composerSpecieList(limit?: number, name?: string, offset?: number, options?: AxiosRequestConfig) {
        return ComposerApiFp(this.configuration).composerSpecieList(limit, name, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Specie
     * @param {number} id A unique integer value identifying this specie.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComposerApi
     */
    public composerSpecieRetrieve(id: number, options?: AxiosRequestConfig) {
        return ComposerApiFp(this.configuration).composerSpecieRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Tag
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComposerApi
     */
    public composerTagList(limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return ComposerApiFp(this.configuration).composerTagList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Tag
     * @param {number} id A unique integer value identifying this tag.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComposerApi
     */
    public composerTagRetrieve(id: number, options?: AxiosRequestConfig) {
        return ComposerApiFp(this.configuration).composerTagRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Via
     * @param {Via} via 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComposerApi
     */
    public composerViaCreate(via: Via, options?: AxiosRequestConfig) {
        return ComposerApiFp(this.configuration).composerViaCreate(via, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Via
     * @param {number} id A unique integer value identifying this via.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComposerApi
     */
    public composerViaDestroy(id: number, options?: AxiosRequestConfig) {
        return ComposerApiFp(this.configuration).composerViaDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Via
     * @param {number} [connectivityStatementId] 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComposerApi
     */
    public composerViaList(connectivityStatementId?: number, limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return ComposerApiFp(this.configuration).composerViaList(connectivityStatementId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Via
     * @param {number} id A unique integer value identifying this via.
     * @param {PatchedVia} [patchedVia] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComposerApi
     */
    public composerViaPartialUpdate(id: number, patchedVia?: PatchedVia, options?: AxiosRequestConfig) {
        return ComposerApiFp(this.configuration).composerViaPartialUpdate(id, patchedVia, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Via
     * @param {number} id A unique integer value identifying this via.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComposerApi
     */
    public composerViaRetrieve(id: number, options?: AxiosRequestConfig) {
        return ComposerApiFp(this.configuration).composerViaRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Via
     * @param {number} id A unique integer value identifying this via.
     * @param {Via} via 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComposerApi
     */
    public composerViaUpdate(id: number, via: Via, options?: AxiosRequestConfig) {
        return ComposerApiFp(this.configuration).composerViaUpdate(id, via, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MetacellAuthApi - axios parameter creator
 * @export
 */
export const MetacellAuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metacellAuthLoginRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/metacell_auth/login/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metacellAuthLogoutRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/metacell_auth/logout/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetacellAuthApi - functional programming interface
 * @export
 */
export const MetacellAuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetacellAuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metacellAuthLoginRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Login>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metacellAuthLoginRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metacellAuthLogoutRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Logout>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metacellAuthLogoutRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MetacellAuthApi - factory interface
 * @export
 */
export const MetacellAuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetacellAuthApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metacellAuthLoginRetrieve(options?: any): AxiosPromise<Login> {
            return localVarFp.metacellAuthLoginRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metacellAuthLogoutRetrieve(options?: any): AxiosPromise<Logout> {
            return localVarFp.metacellAuthLogoutRetrieve(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetacellAuthApi - object-oriented interface
 * @export
 * @class MetacellAuthApi
 * @extends {BaseAPI}
 */
export class MetacellAuthApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetacellAuthApi
     */
    public metacellAuthLoginRetrieve(options?: AxiosRequestConfig) {
        return MetacellAuthApiFp(this.configuration).metacellAuthLoginRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetacellAuthApi
     */
    public metacellAuthLogoutRetrieve(options?: AxiosRequestConfig) {
        return MetacellAuthApiFp(this.configuration).metacellAuthLogoutRetrieve(options).then((request) => request(this.axios, this.basePath));
    }
}


