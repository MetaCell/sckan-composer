# Generated by Django 4.1.13 on 2025-10-13 12:21

from django.db import migrations, models


def migrate_triple_to_triples_forward(apps, schema_editor):
    """
    Migrate data from triple ForeignKey to triples ManyToMany field.
    Consolidates duplicate records with the same connectivity_statement and relationship.
    """
    ConnectivityStatementTriple = apps.get_model("composer", "ConnectivityStatementTriple")
    
    # Delete any ConnectivityStatementTriple where triple is NULL (and free text was also null or empty - captured in 0094)
    # These are orphaned records
    ConnectivityStatementTriple.objects.filter(triple__isnull=True).delete()
    
    from collections import defaultdict
    groups = defaultdict(list)
    for statement_triple in ConnectivityStatementTriple.objects.filter(
        triple__isnull=False
    ).select_related('triple').iterator(chunk_size=1000):
        key = (statement_triple.connectivity_statement_id, statement_triple.relationship_id)
        groups[key].append(statement_triple)

    records_to_delete_ids = []
    for key, records in groups.items():
        # Keep the first record as the primary one
        primary_record = records[0]
        # Collect all unique triple IDs from all records
        triple_ids = set()
        for record in records:
            if record.triple_id:
                triple_ids.add(record.triple_id)
        # Add all triples to the primary record's M2M field in one operation
        if triple_ids:
            primary_record.triples.add(*triple_ids)
        # Collect IDs of duplicate records to delete
        records_to_delete_ids.extend([record.id for record in records[1:]])

    # Bulk delete duplicate records in chunks to avoid memory issues
    chunk_size = 1000
    for i in range(0, len(records_to_delete_ids), chunk_size):
        chunk = records_to_delete_ids[i:i + chunk_size]
        ConnectivityStatementTriple.objects.filter(id__in=chunk).delete()


def migrate_triple_to_triples_backward(apps, schema_editor):
    """
    Reverse migration: split M2M triples back into separate FK records.
    Creates one ConnectivityStatementTriple record per triple in the M2M field.
    """
    ConnectivityStatementTriple = apps.get_model("composer", "ConnectivityStatementTriple")
    
    records_to_create = []
    records_to_update = []
    
    # Use iterator() with prefetch_related for efficient M2M access
    for statement_triple in ConnectivityStatementTriple.objects.prefetch_related(
        'triples'
    ).iterator(chunk_size=1000):
        triples = list(statement_triple.triples.all())
        
        if len(triples) == 0:
            # No triples, keep the record as is with triple=None
            continue
        elif len(triples) == 1:
            # Single triple, just set the FK
            statement_triple.triple_id = triples[0].id
            records_to_update.append(statement_triple)
        else:
            # Multiple triples: keep first one in current record, create new records for others
            statement_triple.triple_id = triples[0].id
            records_to_update.append(statement_triple)
            
            # Create new records for remaining triples
            for triple in triples[1:]:
                records_to_create.append(
                    ConnectivityStatementTriple(
                        connectivity_statement_id=statement_triple.connectivity_statement_id,
                        relationship_id=statement_triple.relationship_id,
                        triple_id=triple.id,
                    )
                )
    
    # Bulk update existing records in chunks
    chunk_size = 1000
    for i in range(0, len(records_to_update), chunk_size):
        chunk = records_to_update[i:i + chunk_size]
        ConnectivityStatementTriple.objects.bulk_update(chunk, ['triple'], batch_size=chunk_size)
    
    # Bulk create new records in chunks
    for i in range(0, len(records_to_create), chunk_size):
        chunk = records_to_create[i:i + chunk_size]
        ConnectivityStatementTriple.objects.bulk_create(chunk, batch_size=chunk_size)


class Migration(migrations.Migration):

    dependencies = [
        ("composer", "0095_alter_relationship_type"),
    ]

    operations = [
        # Step 1: Add the new ManyToMany field (triples) while keeping the old FK field
        migrations.AddField(
            model_name="connectivitystatementtriple",
            name="triples",
            field=models.ManyToManyField(
                blank=True,
                related_name="statement_triple_relationships",
                to="composer.triple",
            ),
        ),
        
        # Step 2: Migrate data from triple FK to triples M2M
        migrations.RunPython(
            migrate_triple_to_triples_forward,
            migrate_triple_to_triples_backward,
        ),
        
        # Step 3: Remove the old constraint that includes triple field
        migrations.RemoveConstraint(
            model_name="connectivitystatementtriple",
            name="unique_statement_relationship_triple",
        ),
        
        # Step 4: Remove the old triple ForeignKey field
        migrations.RemoveField(
            model_name="connectivitystatementtriple",
            name="triple",
        ),
        
        # Step 5: Add the new unique constraint (without triple field)
        migrations.AddConstraint(
            model_name="connectivitystatementtriple",
            constraint=models.UniqueConstraint(
                fields=("connectivity_statement", "relationship"),
                name="unique_statement_relationship_triple",
            ),
        ),
    ]
